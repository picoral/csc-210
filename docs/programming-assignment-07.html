<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>CSC 210 Fall 2024 - Programming Assignment 07</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">CSC 210 Fall 2024</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./syllabus.html"> 
<span class="menu-text">Syllabus</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./programming-assignments.html"> 
<span class="menu-text">Programming Assignments</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./modules.html"> 
<span class="menu-text">Modules</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./practice.html"> 
<span class="menu-text">Practice Problems</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./start.html"> 
<span class="menu-text">Getting Started</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#pa7-graphcoloring" id="toc-pa7-graphcoloring" class="nav-link active" data-scroll-target="#pa7-graphcoloring">PA7-GraphColoring</a>
  <ul class="collapse">
  <li><a href="#learning-objectives" id="toc-learning-objectives" class="nav-link" data-scroll-target="#learning-objectives">Learning Objectives</a></li>
  <li><a href="#graph-coloring" id="toc-graph-coloring" class="nav-link" data-scroll-target="#graph-coloring">Graph Coloring</a></li>
  <li><a href="#the-assignment" id="toc-the-assignment" class="nav-link" data-scroll-target="#the-assignment">The Assignment</a>
  <ul class="collapse">
  <li><a href="#recursive-backtracking" id="toc-recursive-backtracking" class="nav-link" data-scroll-target="#recursive-backtracking">Recursive Backtracking</a></li>
  <li><a href="#heuristic" id="toc-heuristic" class="nav-link" data-scroll-target="#heuristic">Heuristic</a></li>
  <li><a href="#your-own-approach" id="toc-your-own-approach" class="nav-link" data-scroll-target="#your-own-approach">Your own approach</a></li>
  </ul></li>
  <li><a href="#timing-all-of-the-approaches" id="toc-timing-all-of-the-approaches" class="nav-link" data-scroll-target="#timing-all-of-the-approaches">Timing all of the approaches</a></li>
  <li><a href="#error-handling" id="toc-error-handling" class="nav-link" data-scroll-target="#error-handling">Error handling</a></li>
  <li><a href="#notes-and-suggestions" id="toc-notes-and-suggestions" class="nav-link" data-scroll-target="#notes-and-suggestions">Notes and Suggestions</a></li>
  <li><a href="#grading-criteria" id="toc-grading-criteria" class="nav-link" data-scroll-target="#grading-criteria">Grading Criteria</a></li>
  <li><a href="#submission" id="toc-submission" class="nav-link" data-scroll-target="#submission">Submission</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Programming Assignment 07</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Deadline: October 30, 2024 – Wednesday, 11:30pm</p>
<section id="pa7-graphcoloring" class="level1">
<h1>PA7-GraphColoring</h1>
<p>PA7 is about implementing graph coloring in three different ways.</p>
<section id="learning-objectives" class="level2">
<h2 class="anchored" data-anchor-id="learning-objectives">Learning Objectives</h2>
<p>The goal of this assignment is to practice the following algorithm patterns, data structures, and decomposition approaches.</p>
<ul>
<li><p>Algorithmic patterns: recursive backtracking and heuristic</p></li>
<li><p>Data structure: graphs</p></li>
<li><p>Decomposition: using provided classes other than the Java libraries</p></li>
</ul>
</section>
<section id="graph-coloring" class="level2">
<h2 class="anchored" data-anchor-id="graph-coloring">Graph Coloring</h2>
<p>Many important problems such as coloring a map and register allocation can be expressed as graph coloring problems. See [https://en.wikipedia.org/wiki/Graph_coloring] for examples and mention of Sudoku as a kind of graph coloring problem.</p>
</section>
<section id="the-assignment" class="level2">
<h2 class="anchored" data-anchor-id="the-assignment">The Assignment</h2>
<p>In this assignment you will be implementing graph coloring three different ways: recursive backtracking, heuristic, and your own approach.</p>
<p>The program should have the following usage: java PA7Main infile.mtx [HEURISTIC,BACKTRACK,MINE,TIME]</p>
<p>The input files will be from the SuiteSparse Matrix Collection (https://sparse.tamu.edu/about). See https://math.nist.gov/MatrixMarket/formats.html for a description of the .mtx format. You CAN write similar code to the following code to read in the .mtx format. http://docs.roguewave.com/imsl/java/5.0.1/api/com/imsl/math/SparseMatrixEx2.html. Reading .mtx files will be covered in Section 8.</p>
<p>Example output to standard out is provided in the PublicTestCases/ for HEURISTIC and BACKTRACK. You will be running your own algorithm with the MINE command. The output for TIME is shown below.</p>
<p>Your program should also generate before and after .dot files with the nodes colored. See the before and after .dot files in the PublicTestCases/ subdirectory for examples and carefully read the code at the top of the provided Coloring.java file. You can use whatever node filling colors you would like<br>
(see https://www.graphviz.org/doc/info/colors.html). Writing dot files will be covered in Section 8.</p>
<p>You CAN use the code provided and/or written in Section 8 to read in files, store a graph, and output a graph to a dot file in your PA7.</p>
<section id="recursive-backtracking" class="level3">
<h3 class="anchored" data-anchor-id="recursive-backtracking">Recursive Backtracking</h3>
<p>Will make the decisions starting with node 1 and continuing through the nodes in order. Everytime a node coloring choice is tried, that choice will be checked before recursing to do some pruning. We cannot stop at the first coloring we find, because it is possible that other colorings will use fewer colors.</p>
<pre><code>  Set the color for node 1 to the first color (Coloring.Color.A)
  Call enumerate on node 2
    
  enumerate( graph data structure, current coloring so far, ready to color kth node, 
             min coloring previously found)
        
      if all nodes have been colored then
          process the current coloring:
              does it use fewer colors than min coloring?
              if so then modify min coloring previously found (hint: copyOtherIntoSelf())
          return
      
      if coloring so far has fewer colors than the min coloring previously found
          for all possible colors in order except for NOCOLOR
              if that color does NOT conflict with node k's neighboring colors
                  color kth node with color
                  enumerate( graph data structure, updated coloring, k+1,
                             min coloring previously found )
                  uncolor the kth node</code></pre>
</section>
<section id="heuristic" class="level3">
<h3 class="anchored" data-anchor-id="heuristic">Heuristic</h3>
<pre><code>    for k=1 to num_nodes inclusive
    
        for all possible colors in order except for NOCOLOR
                        
            if that coloring does NOT conflict with node k's neighboring colors                
                color kth node with color
                break out of loop over possible colors for node k       </code></pre>
</section>
<section id="your-own-approach" class="level3">
<h3 class="anchored" data-anchor-id="your-own-approach">Your own approach</h3>
<p>You will also implement the command MINE that executes your own faster algorithm for performing graph coloring. The code you submit should be able to execute the MINE command.</p>
<p>For your own approach you can choose to do one of the following: * improve upon the recursive backtracking approach by putting in more pruning and then show this is faster than the suggested recursive backtracking approach * improve upon the heuristic approach while not resorting to a trivial solution like giving each node its own color</p>
</section>
</section>
<section id="timing-all-of-the-approaches" class="level2">
<h2 class="anchored" data-anchor-id="timing-all-of-the-approaches">Timing all of the approaches</h2>
<p>Using code similar to the following, you will have a TIME command that times all of the algorithms.</p>
<pre><code>        long startTime = System.nanoTime();
        coloring = heuristic(graph);
        long endTime = System.nanoTime();
        long duration = (endTime - startTime) / 1000000;
        System.out.println("heuristic: " + coloring.getNumColors() + " colors, "
                + duration + " milliseconds");</code></pre>
<p>The output for the TIME command will look as follows:</p>
<pre><code>heuristic: 6 colors, 4 milliseconds
mine:      6 colors, 3 milliseconds
backtrack: 4 colors, 50102 milliseconds</code></pre>
<p>None of the grading test cases call TIME, because each time you run the program even on the same input and on the same machine there will be some time variance. Because of that you will probably want to run the timings about 5 times before drawing any conclusions.</p>
<p>INSTEAD, you will be running the TIME command on your machine for the mesh1em6.mtx input. It takes around a minute for the recursive backtracking algorithm on a 2 year old Mac.</p>
</section>
<section id="error-handling" class="level2">
<h2 class="anchored" data-anchor-id="error-handling">Error handling</h2>
<p>All of the inputs will be correctly formed for this assignment.</p>
</section>
<section id="notes-and-suggestions" class="level2">
<h2 class="anchored" data-anchor-id="notes-and-suggestions">Notes and Suggestions</h2>
<ul>
<li><p>To get started, go to the resources page on piazza and click on the PA7-GraphColoring link under programming assignments and then accept the github assignment and repository. Import the github repository into Eclipse as normal. We aren’t using Travis CI anymore. Test things locally in Eclipse and submit all the files to Gradescope to see how you do on the grading test cases.</p></li>
<li><p>The node ids should go from 1 to the number of nodes inclusive, because the sparse matrix market file format (.mtx) stores node ids starting at 1 instead of 0.</p></li>
<li><p>We are providing a Coloring class that keeps track of a mapping of node ids to colors.</p></li>
<li><p>In Section 8 this week, we provided a graph data structure, to which you might need to add a method that returns the neighbors for a node.</p></li>
<li><p>In Section 8 this week, we helped you write the code to read in .mtx files and output a dot file. You will need to modify the dot output code to generate colored nodes. The setting of the colors is up to you and happens in Coloring.java.</p></li>
</ul>
</section>
<section id="grading-criteria" class="level2">
<h2 class="anchored" data-anchor-id="grading-criteria">Grading Criteria</h2>
<p>Half of the PA7 grade will be correctness. For this assignment, there will be some private test cases on Gradescope used for grading. However, note the names of the test cases and realize you can download the .mtx files from the SuiteSparse Matrix Collection (https://sparse.tamu.edu/about).</p>
<p>The other half of the PA7 grade will be broken up as follows: * 25 your decomposition and code clarity * 10 MINE algorithm that does something different than given algorithms * 10 timing results in the README.md file along with a TIME implementation * 5 points for a cool dot file with a coloring in it</p>
<p>Decomposition</p>
<ul>
<li><p>Points will be taken off for copy, pasted, and edited code that should have been encapsulated in a method EXCEPT for in the timing code.</p></li>
<li><p>All of the Java files should be &lt;250 lines of code.</p></li>
<li><p>Each method should be less than 30 lines. This INCLUDES comments, but not the method header. It is easier to read a function if it can all fit on one screen.</p></li>
<li><p>Make things as simple as possible.</p>
<ul>
<li>Only use one Scanner instance.</li>
<li>Don’t use lambda functions or other features in non-standard ways.</li>
<li>In general avoid nested loops. However, can use nested loops to implement the recursive backtracking and heuristic in PA7.</li>
<li>In general, avoid nesting conditionals. However, you can use nested conditionals to implement the recursive backtracking and heuristic in PA7.</li>
<li>Avoid chaining: see the Piazza post for more info</li>
</ul></li>
</ul>
<p>Code Clarity * YOU should be able to read, understand, and explain your own code to someone else a couple days after you wrote it. * No magic numbers * No methods written to just get the test cases to work</p>
<ul>
<li><p>There needs to be a balance between no comments in the body of the methods and a comment for every line in the program. Either extreme will result in points off.</p></li>
<li><p>The file header should include instructions on how someone would use this program. To use the program, one would need to know the input file format.</p></li>
<li><p>Use meaningful variable names. Loop iterators can be simple (i for integers, s for strings, n for numbers, etc.).</p></li>
<li><p>The clearest code examples will be anonymously shown in class.</p></li>
<li><p>The most obfuscated code examples will be anonymously shown in class with suggestions for improvement.</p></li>
</ul>
<p>The coding style in terms of spacing, etc. should be done automatically every time you save in Eclipse. As long as you stick with those defaults, the syntax style should be fine.</p>
</section>
<section id="submission" class="level2">
<h2 class="anchored" data-anchor-id="submission">Submission</h2>
<p>Files that need to be submitted to Gradescope: * all .java files * README.md with the results of timing experiments that compare your improved algorithm to the required algorithms for the input file mesh1em6.mtx * a dot file that shows off your graph coloring skills</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>